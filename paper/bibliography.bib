
@InProceedings{kahl_2004,
author="Kahl, Wolfram",
editor="Kameyama, Yukiyoshi
and Stuckey, Peter J.",
title="Basic Pattern Matching Calculi: a Fresh View on Matching Failure",
booktitle="Functional and Logic Programming",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="276--290",
abstract="We propose pattern matching calculi as a refinement of $\lambda$-calculus that integrates mechanisms appropriate for fine-grained modelling of non-strict pattern matching.",
isbn="978-3-540-24754-8"
}

@article{sestof_1997,
author = {Sestoft, Peter},
year = {1997},
month = {05},
pages = {231-264},
title = {Deriving a Lazy Abstract Machine},
volume = {7},
journal = {Journal of Functional Programming},
doi = {10.1017/S0956796897002712}
}


@inproceedings{launchbury_1993,
author = {Launchbury, John},
title = {A Natural Semantics for Lazy Evaluation},
year = 1993,
isbn = 0897915607,
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/158511.158618},
doi = {10.1145/158511.158618},
abstract = {We define an operational semantics for lazy evaluation which provides an accurate model for sharing. The only computational structure we introduce is a set of bindings which corresponds closely to a heap. The semantics is set at a considerably higher level of abstraction than operational semantics for particular abstract machines, so is more suitable for a variety of proofs. Furthermore, because a heap is explicitly modelled, the semantics provides a suitable framework for studies about space behaviour of terms under lazy evaluation.},
booktitle = {Proceedings of the 20th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {144–154},
numpages = 11,
location = {Charleston, South Carolina, USA},
series = {POPL '93}
}

@misc{haskell_2010_report,
author = {Simon Marlow},
editor = {Simon Marlow},
year = {2023},
title = {Haskell 2010 Language Report},
url = {https://www.haskell.org/onlinereport/haskell2010/}
}



@misc{ghc_guide_lambda_case,
author = {GHC maintainers},
title = {GHC user guide},
year = 2023,
url = {https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/lambda_case.html}
}



@InBook{spj_1987,
  author =    {Simon Peyton-Jones},
  title =        {The implementation of functional languages},
  publisher =    {Prentice-Hall},
  year =         1987}


@article{jones_1992,
  title={Implementing lazy functional languages on stock hardware: the
                  Spineless Tagless G-machine},
  volume={2},
  DOI={10.1017/S0956796800000319},
  number={2},
  journal={Journal of Functional Programming},
  publisher={Cambridge University Press},
  author={Jones, Simon L. Peyton},
  year={1992},
  pages={127–202}}

@article{KLOP200816,
title = {Lambda calculus with patterns},
journal = {Theoretical Computer Science},
volume = {398},
number = {1},
pages = {16-31},
year = {2008},
note = {Calculi, Types and Applications: Essays in honour of M. Coppo, M. Dezani-Ciancaglini and S. Ronchi Della Rocca},
issn = {0304-3975},
doi = {https://doi.org/10.1016/j.tcs.2008.01.019},
url = {https://www.sciencedirect.com/science/article/pii/S0304397508000571},
author = {Jan Willem Klop and Vincent {van Oostrom} and Roel {de Vrijer}},
keywords = {Lambda calculus, Pattern, Combinatory reduction systems (CRS), Unique normal forms, Church–Rosser, Rigid pattern condition, Orthogonality},
abstract = {In this paper we revisit the λ-calculus with patterns, originating from the practice of functional programming language design. We treat this feature in a framework ranging from pure λ-calculus to orthogonal combinatory reduction systems.}
}

@article{barry_kesner_2009,
author = {Jay, Barry and Kesner, Delia},
title = {First-Class Patterns},
year = {2009},
issue_date = {March 2009},
publisher = {Cambridge University Press},
address = {USA},
volume = {19},
number = {2},
issn = {0956-7968},
abstract = {Pure pattern calculus supports pattern-matching functions in which patterns are first-class citizens that can be passed as parameters, evaluated and returned as results. This new expressive power supports two new forms of polymorphism. Path polymorphism allows recursive functions to traverse arbitrary data structures. Pattern polymorphism allows patterns to be treated as parameters which may be collected from various sources or generated from training data. A general framework for pattern calculi is developed. It supports a proof of confluence that is parameterised by the nature of the matching algorithm, suitable for the pure pattern calculus and all other known pattern calculi.},
journal = {Journal of Functional Programming},
month = {mar},
pages = {191–225},
numpages = {35}
}

  

