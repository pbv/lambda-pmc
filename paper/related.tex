
\section{Related work}\label{sec:related}

Chapter 4 of the classic textbook by Peyton Jones~\cite{spj_1987}
defines the semantics of pattern matching using lambda abstractions
with patterns $\lambda p.E$ together with a \textsf{FAIL} expression
and a ``fatbar'' operator. This semantics is
denotational and serves primarly as the basis for defining the
correctness of compilation into case expressions presented in
the subsequent chapter.

Kahl defines a pattern matching calculus and proved its
confluence~\cite{kahl_2004}. This work forms the basis for our
\lambdaPMC\ language and the two semantics. The principle differences
are: (1) our operational semantics deal with lazy evaluation
explicitly and (2) we do not consider the ``empty expression'' corresponding to a
pattern matching failure $\lambda\matchfail$; there is simply no
evaluation in such cases.  Our definitions of normal forms for expressions
and matchings are also novel. % and inspired by the STG machine~\cite{jones_1992}.

Klop et.\@ al.\@~\cite{KLOP200816} re-visit the lambda calculus with
patterns of Peyton~Jones and situates it in the context of more
general combinatory reduction systems (CRSs) and higher-order
rewriting systems.

Several researchers have looked at restricted forms of pattern
calculi.  Bucciarelli et.\@ al.\@~\cite{bucciarelli_et_al_2015} have
looked at characterizing observability for pattern matching restricted
to pairs using a type system based on intersection types.  Inspired by
this work, Alves et.\@ al.\@~\cite{alves_et_al_2020} have defined a
type system based on non-idempotent intersection types to characterize
bounds on the length of normalization sequences for such pattern
calculi.

Wadler~\cite{wadler_1987} introduced \emph{view patterns} that
generalize pattern matching to abstract data types; as seen in Section~\ref{sec:examples},
these are easily translated into \lambdaPMC.
McBride and McKinna~\cite{mcbride_mckinna_2004} have looked at pattern
matching in a dependently-typed setting (where matching refines not
just values but also types) and generalized the notion of views to
allow for  user-defined induction principles.  




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
