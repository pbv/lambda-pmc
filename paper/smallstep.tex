\section{Abstract machine}\label{sec:smallstep}

We will now transform the big-step semantics of
Section~\ref{sec:bigstep} into a small-step semantics for an abstract
machine, i.e.\@ a transition function between configurations where
each transition performs only bounded amount of work. The approach
follows the derivation of the Krivine machine in~\cite{sestof_1997}.

\subsection{Configurations}
Because our big-step semantics has two mutually recursive judgements,
we introduce a \emph{control} component that keeps
track of the current evaluation mode.
\[ \begin{array}{lcll}
     C & && \text{control} \\
     C &::=& \eval e & \text{evaluate expression}\\
     &\mid& \match{\argstack}{m} & \text{evaluate matching with arguments}~A 
\end{array} \]

The next step is to make evaluation order explicit 
in a \emph{stack}.  A stack is a list of \emph{continuations} $\kont$:
\[ \begin{array}{lcll}
     \kont &&& \text{continuations} \\
     \kont &::=& y & \text{push argument} \\
           &\mid& !y & \text{push update} \\
           &\mid& \$ & \text{end matching} \\
           &\mid& ?(\argstack,m) & \text{push alternative} \\
           &\mid& @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}) & \text{push pattern}
   \end{array}
   \]

A machine configuration is a triple
$(\Gamma,C,\retstack)$ of heap, control, 
and return stack.  The initial configuration for evaluating $e$ is
$(\{\},\, \eval e,\, [\,])$.  Evaluation may get ``stuck''
in a configuration
$(\Gamma,\, \match{\argstack}{\matchfail},\, \$:\retstack)$
due to pattern matching failure, or
terminate sucessfully in a
configuration $(\Gamma, \eval w, [\,])$.

\begin{figure*}
  \[
    \begin{array}{rllll} \hline
      & \text{Heap} & \text{Control} & \text{RetStack} & \text{rule} \\ \hline
      & \Gamma & \eval (e~\loc) & \retstack  & \smallrule{App1} \\
      %%%
      \Longrightarrow & \Gamma & \eval e  & \loc:\retstack    \\[2ex]
      %%
      & \Gamma & \eval \lambda m & \loc:\retstack & \smallrule{App2} \\
      \Longrightarrow & \Gamma & \eval \lambda (\matcharg{\loc}{m}) & \retstack\\
      \multicolumn{5}{l}{\text{if}~\arity{m}>0} \\[2ex]
      %%%
      & \Gamma & \eval \lambda m & \retstack & \smallrule{Sat} \\
      \Longrightarrow & \Gamma & \match{[\,]}{m} & \$:\retstack  \\
      \multicolumn{5}{l}{\text{if}~ \arity{m}=0}\\[2ex]
      %%%
      & \Gamma[\loc\mapsto e] & \eval \loc & \retstack & \smallrule{Var} \\
      \Longrightarrow & \Gamma & \eval e  & !\loc : \retstack &   \\[2ex]
      %%%
      & \Gamma  & \eval w  & !\loc : \retstack  & \smallrule{Update}  \\
      \Longrightarrow & \Gamma[\loc\mapsto w] & \eval w   & \retstack & \\[2ex]
      %%%
      & \Gamma & \eval \llet{\{x_i=e_i\}}{e'}  & \retstack & \smallrule{Let} \\
      \Longrightarrow & \Gamma[\loc_i\mapsto \widehat{e_i}] & \eval e'[\loc_1/x_1,\ldots,\loc_n/x_n]   & \retstack \\
      \multicolumn{5}{l}{\text{where}~\loc_i~\text{are fresh and}~ % wrt}~\Gamma,S,e_i
      \widehat{e}_i = e_i[\loc_1/x_1,\ldots,\loc_n/x_n]}   \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{\matchreturn{e}} & \retstack &  \smallrule{Return1A} \\
      \Longrightarrow & \Gamma & \match{[\,]}{\matchreturn{\matcharg{A}{e}}} & \retstack & \\
      \multicolumn{5}{l}{\text{if}~\argstack \neq [\,]} \\[2ex]
      & \Gamma & \match {[\,]}{\matchreturn{e}} & \$:\retstack &  \smallrule{Return1B} \\
      \Longrightarrow & \Gamma & \eval{e} & \retstack & \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{\matchfail} & \retstack & \smallrule{Return1C} \\
      \Longrightarrow & \Gamma & \match{[\,]}{\matchfail} & \retstack \\
      \multicolumn{5}{l}{\text{if}~\argstack \neq [\,]} \\[2ex]
      %%%
      & \Gamma & \match {[\,]}{\matchreturn{e}} & (?(\argstack',m)):\retstack & \smallrule{Return2} \\
      \Longrightarrow & \Gamma & \match {[\,]}{\matchreturn{e}} & \retstack\\[2ex]
      %%%
      & \Gamma & \match {(y:\argstack)} {(\matchpat{x}{m})}  & \retstack & \smallrule{Bind} \\
      \Longrightarrow & \Gamma & \match{\argstack}{m[y/x]}  & \retstack & \\[2ex]
      %%%
      & \Gamma & \match  {(y:\argstack)}{(\matchpat{\constr{c}{\vec{p}}}{m})}  & \retstack & \smallrule{Cons1} \\
      \Longrightarrow & \Gamma & \eval y  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack & \\[2ex]
      %%%
      & \Gamma & \eval \constr{c}{y_1,\ldots,y_n}  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack &  \smallrule{Cons2} \\
      \Longrightarrow & \Gamma & \match{\argstack}{(\matcharg{y_1}{p_1} \amatchpat \ldots \matcharg{y_n}{p_n} \amatchpat m)}  & \retstack \\
      \multicolumn{5}{l}{\text{if}~ |\vec{p}|=n} \\[2ex]
      %%
      & \Gamma & \eval \constr{c'}{y_1,\ldots,y_n} & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack &  \smallrule{Fail} \\
      \Longrightarrow & \Gamma & \match {[\,]}{\matchfail}  &  \retstack \\
      \multicolumn{5}{l}{\text{if}~ c\neq c' \lor |\vec{p}|\neq n} \\[2ex]
            %%%
      & \Gamma & \match {\argstack}{(\matcharg{e}{\matchpat{\constr{c}{\vec{p}}}{m}})} & \retstack & \smallrule{Guard} \\
      \Longrightarrow & \Gamma & \eval e  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack & \\[2ex]
      %%%%   
      & \Gamma & \match{\argstack}{(\matcharg{y}{m})} & \retstack & \smallrule{Arg} \\
      \Longrightarrow & \Gamma & \match{(y:\argstack)}{m}  & \retstack \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{(\matchalt{m_1}{m_2})} & \retstack & \smallrule{Alt1} \\
      \Longrightarrow & \Gamma & \match{\argstack}{m_1}   &?(\argstack,m_2):\retstack & \\[2ex]
  %%
  & \Gamma & \match{[\,]}{\matchfail}  & ?(\argstack,m):\retstack & \smallrule{Alt2} \\
  \Longrightarrow & \Gamma & \match{\argstack}{m}  & \retstack 
    \end{array}
  \]
    
  
  \caption{Abstract machine transition rules}\label{fig:smallstep}
\end{figure*}

\subsection{Transitions}

The transitions between configurations are given by rules in
Figure~\ref{fig:smallstep}.

Rules~\smallrule{App1}, \smallrule{Var}, \smallrule{Update}
and \smallrule{Let} are identical to the ones in the first version of
Sestof's abstract machine~\cite{sestof_1997}.

Rule~\smallrule{App2} and \smallrule{Sat} handle application
and matching evaluations, respectively. Note that the
side conditions on $\arity{m}$ ensure at most one
rule applies.
As in the bigstep semantics, rule \smallrule{Sat} switches
from evaluating an expression to a
matching, pushing a mark `\$' onto the return stack
to allow checking when no pending alternatives
are available (rule~\smallrule{Return1B}).

Rule~\smallrule{Cons1} switches from evaluating a matching
to an expression in order to perform a pattern match, pushing
a continuation onto the return stack.
Rule~\smallrule{Cons2} and \smallrule{Fail} handle
the successful and unsucessful pattern match.
Rules~\smallrule{Alt1} and \smallrule{Alt2} deal
with alternatives.
Finally, rule~\smallrule{Arg} push arguments on the local argument stack.

\subsection{Examples}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
