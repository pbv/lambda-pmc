\section{Abstract machine}\label{sec:smallstep}

We will now transform the big-step semantics of
Section~\ref{sec:bigstep} into a small-step semantics for an abstract
machine, i.e.\@ a transition function between configurations where
each transition performs only bounded amount of work. The approach
follows the derivation of the Krivine machine in~\cite{sestof_1997}.

\subsection{Configurations}
Because our big-step semantics has two mutually recursive judgements,
we introduce a \emph{control} component that keeps
track of the current evaluation mode.
\[ \begin{array}{lcll}
     C & && \text{control} \\
     C &::=& \eval e & \text{evaluate expression}\\
     &\mid& \match{\argstack}{m} & \text{evaluate matching with arguments}~A 
\end{array} \]

The next step is to make evaluation order explicit 
in a \emph{stack}.  A stack is a list of \emph{continuations} $\kont$:
\[ \begin{array}{lcll}
     \kont &&& \text{continuations} \\
     \kont &::=& y & \text{push argument} \\
           &\mid& !y & \text{push update} \\
           &\mid& \$ & \text{end matching} \\
           &\mid& ?(\argstack,m) & \text{push alternative} \\
           &\mid& @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}) & \text{push pattern}
   \end{array}
   \]

A machine configuration is a triple
$(\Gamma,C,\retstack)$ of heap, control, 
and return stack.  The initial configuration for evaluating $e$ is
$(\{\},\, \eval e,\, [\,])$.  Evaluation may get ``stuck''
in a configuration
$(\Gamma,\, \match{\argstack}{\matchfail},\, \$:\retstack)$
due to pattern matching failure, or
terminate sucessfully in a
configuration $(\Gamma, \eval w, [\,])$.

\begin{figure*}
  \[
    \begin{array}{rllll} \hline
      & \text{Heap} & \text{Control} & \text{RetStack} & \text{rule} \\ \hline
      & \Gamma & \eval (e~\loc) & \retstack  & \smallrule{App1} \\
      %%%
      \Longrightarrow & \Gamma & \eval e  & \loc:\retstack    \\[2ex]
      %%
      & \Gamma & \eval \lambda m & \loc:\retstack & \smallrule{App2} \\
      \Longrightarrow & \Gamma & \eval \lambda (\matcharg{\loc}{m}) & \retstack\\
      \multicolumn{5}{l}{\text{if}~\arity{m}>0} \\[2ex]
      %%%
      & \Gamma & \eval \lambda m & \retstack & \smallrule{Sat} \\
      \Longrightarrow & \Gamma & \match{[\,]}{m} & \$:\retstack  \\
      \multicolumn{5}{l}{\text{if}~ \arity{m}=0}\\[2ex]
      %%%
      & \Gamma[\loc\mapsto e] & \eval \loc & \retstack & \smallrule{Var} \\
      \Longrightarrow & \Gamma & \eval e  & !\loc : \retstack &   \\[2ex]
      %%%
      & \Gamma  & \eval w  & !\loc : \retstack  & \smallrule{Update}  \\
      \Longrightarrow & \Gamma[\loc\mapsto w] & \eval w   & \retstack & \\[2ex]
      %%%
      & \Gamma & \eval \llet{\{x_i=e_i\}}{e'}  & \retstack & \smallrule{Let} \\
      \Longrightarrow & \Gamma[\loc_i\mapsto \widehat{e_i}] & \eval e'[\loc_1/x_1,\ldots,\loc_n/x_n]   & \retstack \\
      \multicolumn{5}{l}{\text{where}~\loc_i~\text{fresh wrt}~\Gamma,S,e_i,e'~\text{and}~\widehat{e}_i = e_i[\loc_1/x_1,\ldots,\loc_n/x_n]}   \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{\matchreturn{e}} & \retstack &  \smallrule{Return1A} \\
      \Longrightarrow & \Gamma & \match{[\,]}{\matchreturn{\matcharg{A}{e}}} & \retstack & \\
      \multicolumn{5}{l}{\text{if}~\argstack \neq [\,]} \\[2ex]
      & \Gamma & \match {[\,]}{\matchreturn{e}} & \$:\retstack &  \smallrule{Return1B} \\
      \Longrightarrow & \Gamma & \eval{e} & \retstack & \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{\matchfail} & \retstack & \smallrule{Return1C} \\
      \Longrightarrow & \Gamma & \match{[\,]}{\matchfail} & \retstack \\
      \multicolumn{5}{l}{\text{if}~\argstack \neq [\,]} \\[2ex]
      %%%
      & \Gamma & \match {[\,]}{\matchreturn{e}} & (?(\argstack',m)):\retstack & \smallrule{Return2} \\
      \Longrightarrow & \Gamma & \match {[\,]}{\matchreturn{e}} & \retstack\\[2ex]
      %%%
      & \Gamma & \match {(y:\argstack)} {(\matchpat{x}{m})}  & \retstack & \smallrule{Bind} \\
      \Longrightarrow & \Gamma & \match{\argstack}{m[y/x]}  & \retstack & \\[2ex]
      %%%
      & \Gamma & \match  {(y:\argstack)}{(\matchpat{\constr{c}{\vec{p}}}{m})}  & \retstack & \smallrule{Cons1} \\
      \Longrightarrow & \Gamma & \eval y  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack & \\[2ex]
      %%%
      & \Gamma & \eval \constr{c}{y_1,\ldots,y_n}  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack &  \smallrule{Cons2} \\
      \Longrightarrow & \Gamma & \match{\argstack}{(\matcharg{y_1}{p_1} \amatchpat \ldots \matcharg{y_n}{p_n} \amatchpat m)}  & \retstack \\
      \multicolumn{5}{l}{\text{if}~ |\vec{p}|=n} \\[2ex]
      %%
      & \Gamma & \eval \constr{c'}{y_1,\ldots,y_n} & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack &  \smallrule{Fail} \\
      \Longrightarrow & \Gamma & \match {[\,]}{\matchfail}  &  \retstack \\
      \multicolumn{5}{l}{\text{if}~ c\neq c' \lor |\vec{p}|\neq n} \\[2ex]
            %%%
      & \Gamma & \match {\argstack}{(\matcharg{e}{\matchpat{\constr{c}{\vec{p}}}{m}})} & \retstack & \smallrule{Guard} \\
      \Longrightarrow & \Gamma & \eval e  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack & \\[2ex]
      %%%%   
      & \Gamma & \match{\argstack}{(\matcharg{y}{m})} & \retstack & \smallrule{Arg} \\
      \Longrightarrow & \Gamma & \match{(y:\argstack)}{m}  & \retstack \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{(\matchalt{m_1}{m_2})} & \retstack & \smallrule{Alt1} \\
      \Longrightarrow & \Gamma & \match{\argstack}{m_1}   &?(\argstack,m_2):\retstack & \\[2ex]
  %%
  & \Gamma & \match{[\,]}{\matchfail}  & ?(\argstack,m):\retstack & \smallrule{Alt2} \\
  \Longrightarrow & \Gamma & \match{\argstack}{m}  & \retstack 
    \end{array}
  \]
    
  
  \caption{Abstract machine transition rules}\label{fig:smallstep}
\end{figure*}

\subsection{Transitions}

The transitions between configurations are given by rules in
Figure~\ref{fig:smallstep}.

Rules~\smallrule{App1}, \smallrule{Var}, \smallrule{Update}
and \smallrule{Let} are identical to the ones in the first version of
Sestof's abstract machine~\cite{sestof_1997}.

Rule~\smallrule{App2} and \smallrule{Sat} handle application
and matching evaluations, respectively. Note that the
side conditions on $\arity{m}$ ensure at most one
rule applies.
As in the bigstep semantics, rule \smallrule{Sat} switches
from evaluating an expression to a
matching, pushing a mark `\$' onto the return stack
to allow checking when no pending alternatives
are available (rule~\smallrule{Return1B}).

Rule~\smallrule{Cons1} switches from evaluating a matching
to an expression in order to perform a pattern match, pushing
a continuation onto the return stack.
Rule~\smallrule{Cons2} and \smallrule{Fail} handle
the successful and unsucessful pattern match.
Rules~\smallrule{Alt1} and \smallrule{Alt2} deal
with alternatives.
Finally, rule~\smallrule{Arg} push arguments on the local argument stack.


\subsection{Soundness}
We are ready to state and prove the correspondence between the big-step
semantics of Section~\ref{sec:bigstep} and the small-step semantics of
Figure~\ref{fig:smallstep}.

The first result states that each big-step evaluation corresponds to a
sequence of small-step transitions in the machine.  Because the
evaluation of expressions and matching are mutually recursive we must
prove the result for both evaluations simultaneously.  We use
$\Rightarrow^{*}$ for the reflexive and transitive closure of the
transition relation.

\begin{theorem}
  If
  \[ \Gamma; \lset; e \expev \Delta; w \]
  then for all $S$
  \[ (\Gamma, \eval e,  \retstack) \Rightarrow^{*}
    (\Delta, \eval w, \retstack)
  \]

  If
  \[ \Gamma; \lset; \argstack; m \matev \Delta; m'
  \]
  then for all $S$
  \[
    (\Gamma, \match{\argstack}{m}, \retstack) \Rightarrow^{*}
    (\Delta, \match{[\,]}{m'}, \retstack)
  \]
\end{theorem}

\begin{proof} The proof is by induction on the height of
  the evaluation derivations of $\expev$ and $\matev$.
  We proceed by analysis on the last rule used.

  \paragraph{Case \bigrule{App}}
  The evaluation rule is
  \[ \prooftree
    \Gamma;\lset; e \expev \Delta;\lambda m \and
    \Delta;\lset; \lambda (\matcharg{y}{m}) \expev \Theta; w
    \justifies
    \Gamma;\lset; (e~y) \expev \Theta; w
    \endprooftree
  \]
  Let $S' = y:S$; applying the induction hypothesis we get
  \begin{gather*}
    (\Gamma, \eval e, S') \Rightarrow^{*} (\Delta, \eval (\lambda m), S') \\
    (\Delta, \eval \lambda (\matcharg{y}{m}), S) \Rightarrow^{*} (\Theta, \eval e, S)
  \end{gather*}
  Because $\lambda m$ is in whnf we know that $\arity{m}>0$.
  We obtain the proof obligation as follows:
  \[ \begin{split}
    (\Gamma, \eval (e~y), S) &\stackrel{\textsc{App1}}{\Rightarrow}
    (\Gamma, \eval e, y:S) \Rightarrow^{*} (\Delta, \eval (\lambda m), y:S) \\
    & \stackrel{\textsc{App2}}{\Rightarrow} (\Delta, \eval \lambda
    (\matcharg{y}{m}), S) \Rightarrow^{*} (\Theta, \eval e, S)
  \end{split}
\]

\paragraph{Case \bigrule{Sat}}
The evaluation rule is
\[
  \prooftree
  \arity{m}= 0 \and
  \Gamma; \lset; [\,];\, m \matev \Delta;\matchreturn{e} \and
  \Delta; \lset; e \expev \Theta;\,w
  \justifies
  \Gamma;\lset; \lambda m \expev \Theta;w
  \endprooftree
\]
Let $\retstack' = \$:\retstack$; the induction hypotheses give
\begin{gather*}
  (\Gamma, \match{[\,]}{m}, \retstack') \Rightarrow^{*}
  (\Delta, \match{[\,]}{\matchreturn{e}}, \retstack') \\
  (\Delta, \eval e, \retstack) \Rightarrow^{*}
  (\Theta, \eval w, \retstack)
\end{gather*}
We obtain the proof obligation as
\[
  \begin{split}
    (\Gamma, \eval \lambda m, \retstack) & \stackrel{\textsc{Sat}}{\Rightarrow}
    (\Gamma, \match{[\,]}{m}, \$:\retstack) \Rightarrow^{*}
    (\Delta, \match{[\,]}{\matchreturn{e}}, \$:\retstack) \\
    & \stackrel{\textsc{Return1B}}{\Rightarrow}
    (\Delta, \eval{e}, \retstack) \Rightarrow^{*} (\Theta, \eval{w}, \retstack)    
  \end{split}
  \]

  \paragraph{Case \bigrule{Var}}
  The evaluation rule is
  \[
    \prooftree
    \Gamma;\lset\cup\{\loc\}; e \expev \Delta; w 
    \justifies
    \Gamma[\loc\mapsto e]; \lset; \loc \expev \Delta[\loc\mapsto w]; w
    \endprooftree 
  \]
  Let $S' = \loc:S$. Applying the induction hypothesis to
  the premise gives
  \[
    (\Gamma, \eval{e}, S') \Rightarrow^{*} (\Delta, \eval{w}, S')
  \]
  We obtain the proof obligation as
  \[
    \begin{split}
      (\Gamma[\loc\mapsto e], \eval{\loc}, S) &
      \stackrel{\textsc{Var}}{\Rightarrow} (\Gamma, \eval{e}, S')  \Rightarrow^{*} (\Delta,\eval{w}, S') \\
      & \stackrel{\textsc{Update}}{\Rightarrow} (\Delta[\loc\mapsto w], \eval{w}, S)
      \end{split}    
  \]
  
  \paragraph{Case \bigrule{Return}}
  The evaluation rule is
  \[
    \prooftree
    \justifies
    \Gamma; \lset; \argstack; \matchreturn{e} \matev \Gamma; \matchreturn{\matcharg{\argstack}{e}}
    \endprooftree     
  \]
  The proof obligation follows by an application of \smallrule{Return1A}:
  \[
  (\Gamma, \match{\argstack}{\matchreturn{e}}, S)
  \stackrel{\textsc{Return1A}}{\Rightarrow}
  (\Gamma, \match{[\,]}{\matchreturn{\matcharg{\argstack}{e}}}, S)
  \]

  \paragraph{Case \bigrule{Fail}}
  The evaluation rule is
  \[
    \prooftree
    \justifies
    \Gamma; \lset; A; \matchfail \matev \Gamma;\matchfail
    \endprooftree
  \]
  The proof obligation follows trivally by either the empty sequence
  (if $A=[\,]$) or an application of \smallrule{Return1C}.
    
  \paragraph{Case \bigrule{Arg}}
  The evaluation rule is
  \[
    \prooftree
    \Gamma; \lset; (y:\argstack); m \matev \Delta;\matchresult
    \justifies
    \Gamma; \lset; \argstack; \matcharg{y}{m} \matev \Delta; \matchresult
    \endprooftree    
  \]
  The induction hypothesis gives
  \[
    (\Gamma, \match{(y:\argstack)}{m}, \retstack) \Rightarrow^{*}
    (\Delta, \match{[\,]}{\matchresult}, \retstack) 
  \]
  Using \smallrule{Arg} gives the required proof obligation:
  \[ 
      (\Gamma, \match{\argstack}{(\matcharg{y}{m})}, \retstack)
      \stackrel{\textsc{Arg}}{\Rightarrow}
      (\Gamma, \match{(y:\argstack)}{m}, \retstack)
      \Rightarrow^{*} (\Delta, \match{[\,]}{\matchresult}, \retstack)    
    \]

    \paragraph{Case \bigrule{Alt1}}
    The evaluation rule is
    \[
    \prooftree
    \Gamma;\lset;\argstack; m_1 \matev \Delta;\matchreturn{e}
    \justifies
    \Gamma;\lset;\argstack; (\matchalt{m_1}{m_2}) \matev \Delta;\matchreturn{e}
    \endprooftree       
  \]
  Let $S' = (?(A,m_2)):S$. Applying the induction hypothesis gives
  \[
    (\Gamma, \match{\argstack}{m_1}, S') \Rightarrow^{*}
    (\Delta, \match{[\,]}{\matchreturn{e}}, S')
  \]
  The proof obligation is
  \[
    \begin{split}
      (\Gamma, \match{\argstack}{(\matchalt{m_1}{m_2})}, S) &
      \stackrel{\textsc{Alt1}}{\Rightarrow}
      (\Gamma, \match{\argstack}{m_1}, S') \Rightarrow^{*}
      (\Delta, \match{[\,]}{\matchreturn{e}}, S') \\
      & \stackrel{\textsc{Return2}}{\Rightarrow}
      (\Delta, \match{[\,]}{\matchreturn{e}}, S)
    \end{split}
  \]

  \paragraph{Case \bigrule{Alt2}}
  The evaluation rule is
  \[
    \prooftree
    \Gamma;\lset;\argstack; m_1 \matev \Delta;\matchfail  \qquad
    \Delta;\lset;\argstack; m_2 \matev \Theta; \matchresult
    \justifies
    \Gamma;\lset;\argstack; (\matchalt{m_1}{m_2}) \matev \Theta;\matchresult
    \endprooftree
  \]
  Let $S' = (?(\argstack,m_2)):S$. The induction hypothesis gives
  \begin{gather*}
    (\Gamma, \match{\argstack}{m_1}, S') \Rightarrow^{*}
    (\Delta, \match{[\,]}{\matchfail}, S') \\
    (\Delta, \match{\argstack}{m_2}, S) \Rightarrow^{*}
    (\Theta, \match{[\,]}{m'}, S)
  \end{gather*}
  We can obtain the proof obligation as follows:
  \[
    \begin{split}
      (\Gamma, \match{\argstack}{(\matchalt{m_1}{m_2})}, S)
      & \stackrel{\textsc{Alt1}}{\Rightarrow}
      (\Gamma, \match{\argstack}{m_1}, S')
      \Rightarrow^{*} (\Delta, \match{[\,]}{\matchfail}, S') \\
      & \stackrel{\textsc{Alt2}}{\Rightarrow}
      (\Delta, \match{\argstack}{m_2}, S) \Rightarrow^{*}
      (\Theta, \match{[\,]}{m'}, S)
      \end{split}
  \]
  \end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
