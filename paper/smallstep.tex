\section{Abstract machine}\label{sec:smallstep}

We will now transform the big-step semantics of
Section~\ref{sec:bigstep} into a small-step semantics for an abstract
machine, i.e.\@ a transition function between configurations where
each transition performs only bounded amount of work. The approach
follows the derivation of the Krivine machine in~\cite{sestof_1997}.

\subsection{Configurations}
Because our big-step semantics has two mutually recursive judgements,
we introduce a \emph{control} component that keeps
track of the current evaluation mode.
\[ \begin{array}{lcll}
     C & && \text{control} \\
     C &::=& \eval e & \text{evaluate expression}\\
     &\mid& \match{\argstack}{m} & \text{evaluate matching with arguments}~A 
\end{array} \]

The next step is to make evaluation order explicit 
in a \emph{stack}.  A stack is a list of \emph{continuations} $\kont$:
\[ \begin{array}{lcll}
     \kont &&& \text{continuations} \\
     \kont &::=& y & \text{push argument} \\
           &\mid& !y & \text{push update} \\
           &\mid& \$ & \text{end matching} \\
           &\mid& ?(\argstack,m) & \text{push alternative} \\
           &\mid& @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}) & \text{push pattern}
   \end{array}
   \]

A machine configuration is a triple
$(\Gamma,C,\retstack)$ of heap, control, 
and return stack.  The initial configuration for evaluating $e$ is
$(\{\},\, \eval e,\, [\,])$.  Evaluation may get ``stuck''
in a configuration
$(\Gamma,\, \match{\argstack}{\matchfail},\, \$:\retstack)$
due to pattern matching failure, or
terminate successfully in a
configuration $(\Gamma, \eval w, [\,])$.

\begin{figure*}
  \[
    \begin{array}{rllll} \hline
      & \text{Heap} & \text{Control} & \text{RetStack} & \text{rule} \\ \hline
      & \Gamma & \eval (e~\loc) & \retstack  & \smallrule{App1} \\
      %%%
      \Longrightarrow & \Gamma & \eval e  & \loc:\retstack    \\[2ex]
      %%
      & \Gamma & \eval \lambda m & \loc:\retstack & \smallrule{App2} \\
      \Longrightarrow & \Gamma & \eval \lambda (\matcharg{\loc}{m}) & \retstack\\
      \multicolumn{5}{l}{\text{if}~\arity{m}>0} \\[2ex]
      %%%
      & \Gamma & \eval \lambda m & \retstack & \smallrule{Sat} \\
      \Longrightarrow & \Gamma & \match{[\,]}{m} & \$:\retstack  \\
      \multicolumn{5}{l}{\text{if}~ \arity{m}=0}\\[2ex]
      %%%
      & \Gamma[\loc\mapsto e] & \eval \loc & \retstack & \smallrule{Var} \\
      \Longrightarrow & \Gamma & \eval e  & !\loc : \retstack &   \\[2ex]
      %%%
      & \Gamma  & \eval w  & !\loc : \retstack  & \smallrule{Update}  \\
      \Longrightarrow & \Gamma[\loc\mapsto w] & \eval w   & \retstack & \\[2ex]
      %%%
      & \Gamma & \eval \llet{\{x_i=e_i\}}{e'}  & \retstack & \smallrule{Let} \\
      \Longrightarrow & \Gamma[\loc_i\mapsto \widehat{e_i}] & \eval e'[\loc_1/x_1,\ldots,\loc_n/x_n]   & \retstack \\
      \multicolumn{5}{l}{\text{where}~\loc_i~\text{are fresh and}~ % wrt}~\Gamma,S,e_i
      \widehat{e}_i = e_i[\loc_1/x_1,\ldots,\loc_n/x_n]}   \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{\matchreturn{e}} & \retstack &  \smallrule{Return1A} \\
      \Longrightarrow & \Gamma & \match{[\,]}{\matchreturn{\matcharg{A}{e}}} & \retstack & \\
      \multicolumn{5}{l}{\text{if}~\argstack \neq [\,]} \\[2ex]
      & \Gamma & \match {[\,]}{\matchreturn{e}} & \$:\retstack &  \smallrule{Return1B} \\
      \Longrightarrow & \Gamma & \eval{e} & \retstack & \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{\matchfail} & \retstack & \smallrule{Return1C} \\
      \Longrightarrow & \Gamma & \match{[\,]}{\matchfail} & \retstack \\
      \multicolumn{5}{l}{\text{if}~\argstack \neq [\,]} \\[2ex]
      %%%
      & \Gamma & \match {[\,]}{\matchreturn{e}} & (?(\argstack',m)):\retstack & \smallrule{Return2} \\
      \Longrightarrow & \Gamma & \match {[\,]}{\matchreturn{e}} & \retstack\\[2ex]
      %%%
      & \Gamma & \match {(y:\argstack)} {(\matchpat{x}{m})}  & \retstack & \smallrule{Bind} \\
      \Longrightarrow & \Gamma & \match{\argstack}{m[y/x]}  & \retstack & \\[2ex]
      %%%
      & \Gamma & \match  {(y:\argstack)}{(\matchpat{\constr{c}{\vec{p}}}{m})}  & \retstack & \smallrule{Cons1} \\
      \Longrightarrow & \Gamma & \eval y  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack & \\[2ex]
      %%%
      & \Gamma & \eval \constr{c}{y_1,\ldots,y_n}  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack &  \smallrule{Cons2} \\
      \Longrightarrow & \Gamma & \match{\argstack}{(\matcharg{y_1}{p_1} \amatchpat \ldots \matcharg{y_n}{p_n} \amatchpat m)}  & \retstack \\
      \multicolumn{5}{l}{\text{if}~ |\vec{p}|=n} \\[2ex]
      %%
      & \Gamma & \eval \constr{c'}{y_1,\ldots,y_n} & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack &  \smallrule{Fail} \\
      \Longrightarrow & \Gamma & \match {[\,]}{\matchfail}  &  \retstack \\
      \multicolumn{5}{l}{\text{if}~ c\neq c' \lor |\vec{p}|\neq n} \\[2ex]
            %%%
      & \Gamma & \match {\argstack}{(\matcharg{e}{\matchpat{\constr{c}{\vec{p}}}{m}})} & \retstack & \smallrule{Guard} \\
      \Longrightarrow & \Gamma & \eval e  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack & \\[2ex]
      %%%%   
      & \Gamma & \match{\argstack}{(\matcharg{y}{m})} & \retstack & \smallrule{Arg} \\
      \Longrightarrow & \Gamma & \match{(y:\argstack)}{m}  & \retstack \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{(\matchalt{m_1}{m_2})} & \retstack & \smallrule{Alt1} \\
      \Longrightarrow & \Gamma & \match{\argstack}{m_1}   &?(\argstack,m_2):\retstack & \\[2ex]
  %%
  & \Gamma & \match{[\,]}{\matchfail}  & ?(\argstack,m):\retstack & \smallrule{Alt2} \\
  \Longrightarrow & \Gamma & \match{\argstack}{m}  & \retstack 
    \end{array}
  \]
    
  
  \caption{Abstract machine transition rules}\label{fig:smallstep}
\end{figure*}

\subsection{Transitions}

The transitions between configurations are given by rules in
Figure~\ref{fig:smallstep}.

Rules~\smallrule{App1}, \smallrule{Var}, \smallrule{Update}
and \smallrule{Let} are identical to the ones in the first version of
Sestof's abstract machine~\cite{sestof_1997}.

Rule~\smallrule{App2} and \smallrule{Sat} handle application
and matching evaluations, respectively. Note that the
side conditions on $\arity{m}$ ensure at most one
rule applies.
As in the bigstep semantics, rule \smallrule{Sat} switches
from evaluating an expression to a
matching, pushing a mark `\$' onto the return stack
to allow checking when no pending alternatives
are available (rule~\smallrule{Return1B}).

Rule~\smallrule{Cons1} switches from evaluating a matching
to an expression in order to perform a pattern match, pushing
a continuation onto the return stack.
Rule~\smallrule{Cons2} and \smallrule{Fail} handle
the successful and unsuccessful pattern match.
Rules~\smallrule{Alt1} and \smallrule{Alt2} deal
with alternatives.
Finally, rule~\smallrule{Arg} push arguments on the local argument stack.

\subsection{Examples}

We now present some example programs in \lambdaPMC\ that illustrate the execution of the abstract machine.
Each example will share an initial environment $\Gamma$ with bindings for some basic constructors as to follow the normalized syntax.
\[
  \Gamma = \{ nil = \nil,\ u = \unit \}   
\]
For a first example consider \textit{zipWith} (section \ref{sec:intro}) applied to a thunk that will return a list with a single element.
\[
  \llet{xs = \app{\singlePMC}{u}}{\app{\isShort}{xs}}
\]
The full execution of the machine is presented in figure \ref{fig:ex-short}.
Note that \textit{isShort} stands for the \lambdaPMC\ function and is not a variable.
This example shows the application of most rules, \dots.

\begin{figure*}
\[
  \begin{array}{lllr}
    \hline
    \text{Heap}                             & \text{Control}                                             & \text{Top of Stack}                        & \text{Rule}            \\
    \hline
    \Gamma                                  & \eval{\llet{xs = \app{\singlePMC}{u}}{\app{\isShort}{xs}}} & \text{---}                                 & (\smallrule{Let})      \\
    \Gamma[l_1 \mapsto \app{\singlePMC}{u}]
                                            & \eval{\app{\isShort}{l_1}}                                 & \text{---}                                 & (\smallrule{App1})     \\
    \Gamma[l_1 \mapsto \app{\singlePMC}{u}] & \eval{\isShort}                                            & l_1                                        & (\smallrule{App2})     \\
    \Gamma[l_1 \mapsto \app{\singlePMC}{u}] & \eval{\abstr{(\matcharg{l_1}{\isShortBody}})}              & \text{---}                                 & (\smallrule{Sat})      \\
    \Gamma[l_1 \mapsto \app{\singlePMC}{u}] & \match{[\,]}{\matcharg{l_1}{\isShortBody}}                 & \$                                         & (\smallrule{Arg})      \\
    \Gamma[l_1 \mapsto \app{\singlePMC}{u}] & \match{[l_1]}{\isShortBody}                                & \$                                         & (\smallrule{Alt1})     \\
    \Gamma[l_1 \mapsto \app{\singlePMC}{u}] & \match{[l_1]}{\matchpat{(x : y : ys)}{\retFalse}}          & ?([l_1],\matchpat{ys}{\retTrue})           & (\smallrule{Cons1})    \\
    \Gamma[l_1 \mapsto \app{\singlePMC}{u}] & \eval{l_1}                                                 & @([\,],\matchpat{(x : y : ys)}{\retFalse}) & (\smallrule{Var})      \\
    \Gamma                                  & \eval{\app{\singlePMC}{u}}                                 & !l_1                                       & (\smallrule{App1})     \\
    \Gamma                                  & \eval{\singlePMC}                                          & u                                          & (\smallrule{App2})     \\
    \Gamma                                  & \eval{\abstr{(\matcharg{u}{\matchpat{x}{\retSingle}})}}    & !l_1                                       & (\smallrule{Sat})      \\
    \Gamma                                  & \match{[\,]}{\matcharg{u}{\matchpat{x}{\retSingle}}}       & \$                                         & (\smallrule{Arg})      \\
    \Gamma                                  & \match{[u]}{\matchpat{x}{\retSingle}}                      & \$                                         & (\smallrule{Bind})     \\
    \Gamma                                  & \match{[\,]}{\matchreturn{(u : nil)}}                      & \$                                         & (\smallrule{Return1B}) \\
    \Gamma                                  & \eval{(u : nil)}                                           & !l_1                                       & (\smallrule{Update})   \\
    \Gamma[l_1\mapsto(u : nil)]
                                            & \eval{(u : nil)}                                           & @([\,],\matchpat{(x : y : ys)}{\retFalse}) & (\smallrule{Cons2})    \\
    \Gamma[l_1\mapsto(u : nil)]             & \match{[\,]}{\matcharg{u}{\matchpat{x}{\matchNilList}}}
                                            & ?([l_1],\matchpat{ys}{\retTrue})                           & (\smallrule{Arg})                                                   \\
    \Gamma[l_1\mapsto(u : nil)]             & \match{[u]}{\matchpat{x}{\matchNilList}}
                                            & ?([l_1],\matchpat{ys}{\retTrue})                           & (\smallrule{Bind})                                                  \\
    \Gamma[l_1\mapsto(u : nil)]             & \match{[\,]}{\matchNilList}
                                            & ?([l_1],\matchpat{ys}{\retTrue})                           & (\smallrule{Arg})                                                   \\
    \Gamma[l_1\mapsto(u : nil)]             & \match{[nil]}{\matchpat{(y : ys)}{\retFalse}}              & ?([l_1],\matchpat{ys}{\retTrue})           & (\smallrule{Cons1})    \\
    \Gamma[l_1\mapsto(u : nil)]             & \eval{nil}                                                 & @([\,],\matchpat{(y : ys)}{\retFalse})     & (\smallrule{Var})      \\
    \Gamma[l_1\mapsto(u : nil)]             & \eval{\nil}                                                & !nil                                       & (\smallrule{Update})   \\
    \Gamma[l_1\mapsto(u : nil)]             & \eval{\nil}                                                & @([\,],\matchpat{(y : ys)}{\retFalse})     & (\smallrule{Fail})     \\
    \Gamma[l_1\mapsto(u : nil)]             & \match{[\,]}{\matchfail}                                   & ?([l_1],\matchpat{ys}{\retTrue})           & (\smallrule{Alt2})     \\
    \Gamma[l_1\mapsto(u : nil)]             & \match{[l_1]}{\matchpat{ys}{\retTrue}}                     & \$                                         & (\smallrule{Bind})     \\
    \Gamma[l_1\mapsto(u : nil)]             & \match{[\,]}{\retTrue}                                     & \$                                         & (\smallrule{Retun1B})  \\
    \Gamma[l_1\mapsto(u : nil)]             & \eval{\true}                                               & \text{---}                                 &                        \\
  \end{array}
\]
\caption{Execution of \textit{isShort} applied to a list with a single element \unit}
\label{fig:ex-short}
\end{figure*}

For a second example let us look at an excerpt of an execution of \text{zipWith} (section \ref{sec:examples}) applied as follows.
\[
  \llet{res = \app{tail}{nil}}{\app{\app{\app{zipWith}{mkPair}}{nil}}{res}}
\]
Execution follows the first branch until the control reaches the following state (where $l_1$ is bound to $\app{tail}{nil}$).
\[
  % \begin{array}{l}
    \match{[nil,~l1]}{\matchpat{(x : xs)}{\matchpat{(y : ys)}{\matchreturn{\dots}}}}  \\
    % \eval{nil}  \\
    % \eval{\nil}  \\
    % \match{[]}{\matchfail}  \\
    % \end{array}
\]
The first pattern match fails, and thus any remaining arguments are discarded.
Execution falls through to the second branch until the following state
\[
  \match{[mkPair,~nil,~l1]}{\matchpat{f}{\matchpat{xs'}{\matchpat{ys'}{\matchreturn{\constr{\cons{nil}}}}}}}
\]
Where all arguments are discarded by \smallrule(Bind).
Evaluation never gets stuck because of the match failure in $\app{tail}{nil}$.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
