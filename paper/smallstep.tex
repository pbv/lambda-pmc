\section{Abstract machine}\label{sec:smallstep}

We will now transform the big-step semantics of
Section~\ref{sec:bigstep} into a small-step semantics for an abstract
machine, i.e.\@ a transition function between configurations where
each transition performs only bounded amount of work. The approach
follows the derivation of the Krivine machine in~\cite{sestof_1997}.

\subsection{Configurations}
Because our big-step semantics has two mutually recursive judgements,
we introduce a \emph{control} component that keeps
track of the current evaluation mode.
\[ \begin{array}{lcll}
     C & && \text{control} \\
     C &::=& \eval e & \text{evaluate expression}\\
     &\mid& \match{\argstack}{m} & \text{evaluate matching with arguments}~A 
\end{array} \]

The next step is to make evaluation order explicit 
in a \emph{stack}.  A stack is a list of \emph{continuations} $\kont$:
\[ \begin{array}{lcll}
     \kont &&& \text{continuations} \\
     \kont &::=& y & \text{push argument} \\
           &\mid& !y & \text{push update} \\
           &\mid& \$ & \text{end matching} \\
           &\mid& ?(\argstack,m) & \text{push alternative} \\
           &\mid& @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}) & \text{push pattern}
   \end{array}
   \]

A machine configuration is a triple
$(\Gamma,C,\retstack)$ of heap, control, 
and return stack.  The initial configuration for evaluating $e$ is
$(\{\},\, \eval e,\, [\,])$.  Evaluation may get ``stuck''
in a configuration
$(\Gamma,\, \match{\argstack}{\matchfail},\, \$:\retstack)$
due to pattern matching failure, or
terminate sucessfully in a
configuration $(\Gamma, \eval w, [\,])$.

\begin{figure*}
  \[
    \begin{array}{rllll} \hline
      & \text{Heap} & \text{Control} & \text{RetStack} & \text{rule} \\ \hline
      & \Gamma & \eval (e~\loc) & \retstack  & \smallrule{App1} \\
      %%%
      \Longrightarrow & \Gamma & \eval e  & \loc:\retstack    \\[2ex]
      %%
      & \Gamma & \eval \lambda m & \loc:\retstack & \smallrule{App2} \\
      \Longrightarrow & \Gamma & \eval \lambda (\matcharg{\loc}{m}) & \retstack\\
      \multicolumn{5}{l}{\text{if}~\arity{m}>0} \\[2ex]
      %%%
      & \Gamma & \eval \lambda m & \retstack & \smallrule{Sat} \\
      \Longrightarrow & \Gamma & \match{[\,]}{m} & \$:\retstack  \\
      \multicolumn{5}{l}{\text{if}~ \arity{m}=0}\\[2ex]
      %%%
      & \Gamma[\loc\mapsto e] & \eval \loc & \retstack & \smallrule{Var} \\
      \Longrightarrow & \Gamma & \eval e  & !\loc : \retstack &   \\[2ex]
      %%%
      & \Gamma  & \eval w  & !\loc : \retstack  & \smallrule{Update}  \\
      \Longrightarrow & \Gamma[\loc\mapsto w] & \eval w   & \retstack & \\[2ex]
      %%%
      & \Gamma & \eval \llet{\{x_i=e_i\}}{e'}  & \retstack & \smallrule{Let} \\
      \Longrightarrow & \Gamma[\loc_i\mapsto \widehat{e_i}] & \eval e'[\loc_1/x_1,\ldots,\loc_n/x_n]   & \retstack \\
      \multicolumn{5}{l}{\text{where}~\loc_i~\text{fresh wrt}~\Gamma,S,e_i,e'~\text{and}~\widehat{e}_i = e_i[\loc_1/x_1,\ldots,\loc_n/x_n]}   \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{\matchreturn{e}} & \retstack &  \smallrule{Return1A} \\
      \Longrightarrow & \Gamma & \match{[\,]}{\matchreturn{\matcharg{A}{e}}} & \retstack & \\
      \multicolumn{5}{l}{\text{if}~\argstack \neq [\,]} \\[2ex]
      & \Gamma & \match {[\,]}{\matchreturn{e}} & \$:\retstack &  \smallrule{Return1B} \\
      \Longrightarrow & \Gamma & \eval{e} & \retstack & \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{\matchfail} & \retstack & \smallrule{Return1C} \\
      \Longrightarrow & \Gamma & \match{[\,]}{\matchfail} & \retstack \\
      \multicolumn{5}{l}{\text{if}~\argstack \neq [\,]} \\[2ex]
      %%%
      & \Gamma & \match {[\,]}{\matchreturn{e}} & (?(\argstack',m)):\retstack & \smallrule{Return2} \\
      \Longrightarrow & \Gamma & \match {[\,]}{\matchreturn{e}} & \retstack\\[2ex]
      %%%
      & \Gamma & \match {(y:\argstack)} {(\matchpat{x}{m})}  & \retstack & \smallrule{Bind} \\
      \Longrightarrow & \Gamma & \match{\argstack}{m[y/x]}  & \retstack & \\[2ex]
      %%%
      & \Gamma & \match  {(y:\argstack)}{(\matchpat{\constr{c}{\vec{p}}}{m})}  & \retstack & \smallrule{Cons1} \\
      \Longrightarrow & \Gamma & \eval y  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack & \\[2ex]
      %%%
      & \Gamma & \eval \constr{c}{y_1,\ldots,y_n}  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack &  \smallrule{Cons2} \\
      \Longrightarrow & \Gamma & \match{\argstack}{(\matcharg{y_1}{p_1} \amatchpat \ldots \matcharg{y_n}{p_n} \amatchpat m)}  & \retstack \\
      \multicolumn{5}{l}{\text{if}~ |\vec{p}|=n} \\[2ex]
      %%
      & \Gamma & \eval \constr{c'}{y_1,\ldots,y_n} & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack &  \smallrule{Fail} \\
      \Longrightarrow & \Gamma & \match {[\,]}{\matchfail}  &  \retstack \\
      \multicolumn{5}{l}{\text{if}~ c\neq c' \lor |\vec{p}|\neq n} \\[2ex]
            %%%
      & \Gamma & \match {\argstack}{(\matcharg{e}{\matchpat{\constr{c}{\vec{p}}}{m}})} & \retstack & \smallrule{Guard} \\
      \Longrightarrow & \Gamma & \eval e  & @(\argstack,\matchpat{\constr{c}{\vec{p}}}{m}):\retstack & \\[2ex]
      %%%%   
      & \Gamma & \match{\argstack}{(\matcharg{y}{m})} & \retstack & \smallrule{Arg} \\
      \Longrightarrow & \Gamma & \match{(y:\argstack)}{m}  & \retstack \\[2ex]
      %%%
      & \Gamma & \match {\argstack}{(\matchalt{m_1}{m_2})} & \retstack & \smallrule{Alt1} \\
      \Longrightarrow & \Gamma & \match{\argstack}{m_1}   &?(\argstack,m_2):\retstack & \\[2ex]
  %%
  & \Gamma & \match{[\,]}{\matchfail}  & ?(\argstack,m):\retstack & \smallrule{Alt2} \\
  \Longrightarrow & \Gamma & \match{\argstack}{m}  & \retstack 
    \end{array}
  \]
    
  
  \caption{Abstract machine transition rules}\label{fig:smallstep}
\end{figure*}

\subsection{Transitions}

The transitions between configurations are given by rules in
Figure~\ref{fig:smallstep}.

Rules~\smallrule{App1}, \smallrule{Var}, \smallrule{Update}
and \smallrule{Let} are identical to the ones in the first version of
Sestof's abstract machine~\cite{sestof_1997}.

Rule~\smallrule{App2} and \smallrule{Sat} handle application
and matching evaluations, respectively. Note that the
side conditions on $\arity{m}$ ensure at most one
rule applies.
As in the bigstep semantics, rule \smallrule{Sat} switches
from evaluating an expression to a
matching, pushing a mark `\$' onto the return stack
to allow checking when no pending alternatives
are available (rule~\smallrule{Return1B}).

Rule~\smallrule{Cons1} switches from evaluating a matching
to an expression in order to perform a pattern match, pushing
a continuation onto the return stack.
Rule~\smallrule{Cons2} and \smallrule{Fail} handle
the successful and unsucessful pattern match.
Rules~\smallrule{Alt1} and \smallrule{Alt2} deal
with alternatives.
Finally, rule~\smallrule{Arg} push arguments on the local argument stack.


\subsection{Soundness}
We are ready to state and prove the correspondence between the big-step
semantics of Section~\ref{sec:bigstep} and the small-step semantics of
Figure~\ref{fig:smallstep}.

The first result states that each big-step evaluation corresponds to a
sequence of small-step transitions in the machine.  Because the
evaluation of expressions and matching are mutually recursive we must
prove the result for both evaluations simultaneously.  We use
$\Rightarrow^{*}$ for the reflexive and transitive closure of the
transition relation.

\begin{theorem}
  If
  \[ \Gamma; \lset; e \expev \Delta; w \]
  then for all $S$
  \[ (\Gamma, \eval e,  \retstack) \Rightarrow^{*}
    (\Delta, \eval w, \retstack)
  \]

  If
  \[ \Gamma; \lset; \argstack; m \matev \Delta; m'
  \]
  then for all $S$
  \[
    (\Gamma, \match{\argstack}{m}, \retstack) \Rightarrow^{*}
    (\Delta, \match{[\,]}{m'}, \retstack)
  \]
\end{theorem}

\begin{proof} The proof is by induction on the height of
  the evaluation derivations of $\expev$ and $\matev$.
  We proceed by analysis on the last rule used.

  \paragraph{Case \bigrule{App}}
  The evaluation rule is
  \[ \prooftree
    \Gamma;\lset; e \expev \Delta;\lambda m \and
    \Delta;\lset; \lambda (\matcharg{y}{m}) \expev \Theta; w
    \justifies
    \Gamma;\lset; (e~y) \expev \Theta; w
    \endprooftree
  \]
  Let $S' = y:S$; applying the induction hypothesis we get
  \begin{gather*}
    (\Gamma, \eval e, S') \Rightarrow^{*} (\Delta, \eval (\lambda m), S') \\
    (\Delta, \eval \lambda (\matcharg{y}{m}), S) \Rightarrow^{*} (\Theta, \eval e, S)
  \end{gather*}
  Because $\lambda m$ is in whnf we know that $\arity{m}>0$.
  We obtain the proof obligation as follows:
  \[ \begin{split}
    (\Gamma, \eval (e~y), S) &\stackrel{\textsc{App1}}{\Rightarrow}
    (\Gamma, \eval e, y:S) \Rightarrow^{*} (\Delta, \eval (\lambda m), y:S) \\
    & \stackrel{\textsc{App2}}{\Rightarrow} (\Delta, \eval \lambda
    (\matcharg{y}{m}), S) \Rightarrow^{*} (\Theta, \eval e, S)
  \end{split}
\]

\paragraph{Case \bigrule{Sat}}
The evaluation rule is
\[
  \prooftree
  \arity{m}= 0 \and
  \Gamma; \lset; [\,];\, m \matev \Delta;\matchreturn{e} \and
  \Delta; \lset; e \expev \Theta;\,w
  \justifies
  \Gamma;\lset; \lambda m \expev \Theta;w
  \endprooftree
\]
Let $\retstack' = \$:\retstack$; the induction hypotheses give
\begin{gather*}
  (\Gamma, \match{[\,]}{m}, \retstack') \Rightarrow^{*}
  (\Delta, \match{[\,]}{\matchreturn{e}}, \retstack') \\
  (\Delta, \eval e, \retstack) \Rightarrow^{*}
  (\Theta, \eval w, \retstack)
\end{gather*}
We obtain the proof obligation as
\[
  \begin{split}
    (\Gamma, \eval \lambda m, \retstack) & \stackrel{\textsc{Sat}}{\Rightarrow}
    (\Gamma, \match{[\,]}{m}, \$:\retstack) \Rightarrow^{*}
    (\Delta, \match{[\,]}{\matchreturn{e}}, \$:\retstack) \\
    & \stackrel{\textsc{Return1B}}{\Rightarrow}
    (\Delta, \eval{e}, \retstack) \Rightarrow^{*} (\Theta, \eval{w}, \retstack)    
  \end{split}
  \]

  \paragraph{Case \bigrule{Var}}
  The evaluation rule is
  \[
    \prooftree
    \Gamma;\lset\cup\{\loc\}; e \expev \Delta; w 
    \justifies
    \Gamma[\loc\mapsto e]; \lset; \loc \expev \Delta[\loc\mapsto w]; w
    \endprooftree 
  \]
  Let $S' = \loc:S$. Applying the induction hypothesis to
  the premise gives
  \[
    (\Gamma, \eval{e}, S') \Rightarrow^{*} (\Delta, \eval{w}, S')
  \]
  We obtain the proof obligation as
  \[
    \begin{split}
      (\Gamma[\loc\mapsto e], \eval{\loc}, S) &
      \stackrel{\textsc{Var}}{\Rightarrow} (\Gamma, \eval{e}, S')  \Rightarrow^{*} (\Delta,\eval{w}, S') \\
      & \stackrel{\textsc{Update}}{\Rightarrow} (\Delta[\loc\mapsto w], \eval{w}, S)
      \end{split}    
  \]
  
  \paragraph{Case \bigrule{Return}}
  The evaluation rule is
  \[
    \prooftree
    \justifies
    \Gamma; \lset; \argstack; \matchreturn{e} \matev \Gamma; \matchreturn{\matcharg{\argstack}{e}}
    \endprooftree     
  \]
  The proof obligation follows by an application of \smallrule{Return1A}:
  \[
  (\Gamma, \match{\argstack}{\matchreturn{e}}, S)
  \stackrel{\textsc{Return1A}}{\Rightarrow}
  (\Gamma, \match{[\,]}{\matchreturn{\matcharg{\argstack}{e}}}, S)
  \]

  \paragraph{Case \bigrule{Fail}}
  The evaluation rule is
  \[
    \prooftree
    \justifies
    \Gamma; \lset; A; \matchfail \matev \Gamma;\matchfail
    \endprooftree
  \]
  The proof obligation follows trivally by either the empty sequence
  (if $A=[\,]$) or an application of \smallrule{Return1C}.
    
  \paragraph{Case \bigrule{Arg}}
  The evaluation rule is
  \[
    \prooftree
    \Gamma; \lset; (y:\argstack); m \matev \Delta;\matchresult
    \justifies
    \Gamma; \lset; \argstack; \matcharg{y}{m} \matev \Delta; \matchresult
    \endprooftree    
  \]
  The induction hypothesis gives
  \[
    (\Gamma, \match{(y:\argstack)}{m}, \retstack) \Rightarrow^{*}
    (\Delta, \match{[\,]}{\matchresult}, \retstack) 
  \]
  Using \smallrule{Arg} gives the required proof obligation:
  \[ 
      (\Gamma, \match{\argstack}{(\matcharg{y}{m})}, \retstack)
      \stackrel{\textsc{Arg}}{\Rightarrow}
      (\Gamma, \match{(y:\argstack)}{m}, \retstack)
      \Rightarrow^{*} (\Delta, \match{[\,]}{\matchresult}, \retstack)    
    \]

    \paragraph{Case \bigrule{Alt1}}
    The evaluation rule is
    \[
    \prooftree
    \Gamma;\lset;\argstack; m_1 \matev \Delta;\matchreturn{e}
    \justifies
    \Gamma;\lset;\argstack; (\matchalt{m_1}{m_2}) \matev \Delta;\matchreturn{e}
    \endprooftree       
  \]
  Let $S' = (?(A,m_2)):S$. Applying the induction hypothesis gives
  \[
    (\Gamma, \match{\argstack}{m_1}, S') \Rightarrow^{*}
    (\Delta, \match{[\,]}{\matchreturn{e}}, S')
  \]
  The proof obligation is
  \[
    \begin{split}
      (\Gamma, \match{\argstack}{(\matchalt{m_1}{m_2})}, S) &
      \stackrel{\textsc{Alt1}}{\Rightarrow}
      (\Gamma, \match{\argstack}{m_1}, S') \Rightarrow^{*}
      (\Delta, \match{[\,]}{\matchreturn{e}}, S') \\
      & \stackrel{\textsc{Return2}}{\Rightarrow}
      (\Delta, \match{[\,]}{\matchreturn{e}}, S)
    \end{split}
  \]

  \paragraph{Case \bigrule{Alt2}}
  The evaluation rule is
  \[
    \prooftree
    \Gamma;\lset;\argstack; m_1 \matev \Delta;\matchfail  \qquad
    \Delta;\lset;\argstack; m_2 \matev \Theta; \matchresult
    \justifies
    \Gamma;\lset;\argstack; (\matchalt{m_1}{m_2}) \matev \Theta;\matchresult
    \endprooftree
  \]
  Let $S' = (?(\argstack,m_2)):S$. The induction hypothesis gives
  \begin{gather*}
    (\Gamma, \match{\argstack}{m_1}, S') \Rightarrow^{*}
    (\Delta, \match{[\,]}{\matchfail}, S') \\
    (\Delta, \match{\argstack}{m_2}, S) \Rightarrow^{*}
    (\Theta, \match{[\,]}{m'}, S)
  \end{gather*}
  We can obtain the proof obligation as follows:
  \[
    \begin{split}
      (\Gamma, \match{\argstack}{(\matchalt{m_1}{m_2})}, S)
      & \stackrel{\textsc{Alt1}}{\Rightarrow}
      (\Gamma, \match{\argstack}{m_1}, S')
      \Rightarrow^{*} (\Delta, \match{[\,]}{\matchfail}, S') \\
      & \stackrel{\textsc{Alt2}}{\Rightarrow}
      (\Delta, \match{\argstack}{m_2}, S) \Rightarrow^{*}
      (\Theta, \match{[\,]}{m'}, S)
      \end{split}
  \]
  \end{proof}

  The next result establishes that a sequence of small-step semantics
  corresponds to a big-step evaluation, provided we restrict ourselves
  to balanced evaluations.

  \begin{definition}
    An sequence of evaluation steps
    $(\Gamma,C,\retstack) \Rightarrow^{*}
    (\Delta,C',\retstack)$ is \emph{balanced} if
    the initial and final stacks are identical and every intermediate
    stack is of the form $S' = \kont_1:\kont_2:\ldots:\kont_n:S$, i.e.\@
    an extension of the initial stack.
  \end{definition}

  \begin{definition}
    The \emph{trace} of a sequence of small-step evaluation
    steps $(\Gamma,C,\retstack) \Rightarrow^{*}
    (\Delta,C',\retstack')$ is the sequence of rules used in the evaluation.
  \end{definition}

  Consider now the traces $B$ of balanced evaluations of expressions
  $(\Gamma,\eval{e},\retstack)\Rightarrow^{*}(\Delta,\eval{e'},\retstack)$
  and $B'$ for balanced evaluations of matchings
  $(\Gamma,\match{\argstack}{m},\retstack)\Rightarrow^{*}(\Delta,\match{\argstack'}{m'},\retstack)$.

By inspection of the evaluation rules of Figure~\ref{fig:smallstep} we
can see that such traces must be generated by the following grammars:
\begin{align*}
  B &::= \textsc{App1}~ B~ \textsc{App2}~B ~\mid~
      \textsc{Sat}~B'~ \textsc{Return1B}~B
      ~\mid~ \textsc{Var}~B ~ \textsc{Update} \\
  &~\mid~ \textsc{Let}~B ~\mid~ \varepsilon\\
  B' &::= \textsc{Alt1}~B'~\textsc{Alt2}~B' ~\mid~
       \textsc{Alt1}~B'~\textsc{Return2} \\
    &~\mid~ \textsc{Cons1}~ B ~\textsc{Cons2}~B' ~\mid~
      \textsc{Cons1}~ B~ \textsc{Fail} \\
    &~\mid~ \textsc{Arg}~ B' ~\mid~ \textsc{Bind}~B' 
    ~\mid~ \textsc{Return1A}~B' ~\mid~ \textsc{Return1C}~B' ~\mid~ \varepsilon
\end{align*}
Note that each production in the grammars above corresponds to 
one evaluation rule for $\expev$ or $\matev$.

The last step before we can state the second soundness result is
to see that we can recover the set $\lset$ of locations under evaluation
used in the big-step semantics from the return stack of the small-step
semantics.
\begin{definition}
  Let $\text{upd}(\retstack)$
  be the set of locations marked
  for updates in a stack \retstack, i.e.\@
  $\{ y ~:~ (!y) \in \retstack \}$.
\end{definition}

\begin{theorem}
  If $(\Gamma, \eval{e}, \retstack) \Rightarrow^{*} (\Delta, \eval{w},
  \retstack)$ is a balanced evaluation then
  $\Gamma;\text{upd}(\retstack); e \expev \Delta; w$.

  If $(\Gamma, \match{A}{m}, \retstack) \Rightarrow^{*} (\Delta,
  \match{[\,]}{m'}, \retstack)$ is a balanced evaluation then
  $\Gamma;\text{upd}(\retstack); A;m \matev \Delta;m'$
\end{theorem}

\begin{proof}
  The proof is by induction on the derivation of balanced evaluations
  following the grammar rules above.
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
